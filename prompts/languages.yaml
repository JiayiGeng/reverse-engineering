judge_prompt: |-
  In this task, you will be given a ground truth formal language and a proposed rule describing that formal language, which you need to evaluate for quality. You will then output a score based on a set of assessment criteria.
  Below is the ground truth formal language:
  {ground_truth}

  Evaluate the quality of the following formal language rule:
  {response}

  Score the above formal language rule against the ground truth formal language based on the following criteria (total: 10 points):
  1. Does the provided rule correctly generate the examples given in the ground truth? Your score is determined by how many examples are correctly generated out of the total number of examples. [3 points]
  2. Does the provided rule correctly reverse engineer the ground truth formal language? [5 point]
  3. Is the provided rule in the most simple and straightforward way without extra unused parts (Occam's Razor principle)? Note: If the provided rule is completely incorrect, you should give 0 point for this criterion. [2 point]

  Explain your judgement and return the final score with the type float and following the format below:

  ```judgement
  YOUR JUDGEMENT HERE
  ```
  ```score
  YOUR SCORE HERE
  ```
  
  Response:


observation_descriptive: |-
  In this task, you are given a ``black box`` and need to determine its inner workings. This black box is a formal language that generates some strings.

  Below are past observations have collected from the black box:
  {observations}

  Your task is to reverse engineer the rule underlying this formal language in the following format:
  ```Rule
  YOUR RULE HERE
  ```

  Response:


functional_explicit_eval: |-
  In this task, you are given a ``black box`` and need to determine its inner workings. This black box is a formal language that generates some strings.
  Below are some past observations from the black box:
  {observations}

  Your task is to reverse engineer the rule underlying this formal language by writing an executable Python function to generate strings that correspond to the rule of the black box. 
  The executable Python function should not accept any user input. When the Python function is executed, it should randomly and automatically generate one string that corresponds to the rule of the black box.
  The Python function should allow multiple executions to generate different strings.

  The Python program should be in the following format:
  ```python
  YOUR CODE HERE
  ```

  Response:


functional_implicit_eval: |-
  In this task, you are given a ``black box`` and need to determine its inner workings. This black box is a formal language that generates some strings.
  Below are some past observations from the black box:
  {observations}

  You need to reverse engineer the rule underlying this formal language and generate a string that corresponds to the rule of the black box.

  Output your generated string in the following format:
  ```output
  YOUR RESPONSE HERE
  ```

  Response:


intervention_prompt: |-
  In this task, you are given a ``black box`` and need to determine its inner workings. This black box is a formal language that generates some strings. You will have a series of turns to interact with the black box. On each turn, you can either gather more information to test your hypothesis. To gather more information, you need to come up with a string with a limited length of less than 64 characters, use it to query the black box, and obtain a result indicating whether that string is generated by the black box. All the information gathered across all the turns is used to reverse engineer the black box. Throughout the process, you can decide whether the gathered information is sufficient to correctly identify the workings of the black box, in which case you can stop. Otherwise you need to continue the interaction.

  Concretely, you can perform one of the following actions at each turn: 1) test, or 2) stop. Below is the format for each action.

  Test:
  ```test
  Str
  ```

  Stop:
  ```stop
  stop
  ```
  Note that you should only perform one of the actions above with one input example in your response. 

  Below is your past observations of the black box:
  {observations}
  Response:


reasoning_intervention_prompt: |-
  In this task, you are given a ``black box`` and need to determine its inner workings. This black box is a formal language that generates some strings. You will have a series of turns to interact with the black box. On each turn, you can either gather more information to test your hypothesis. To gather more information, you need to come up with a string, use it to query the black box, and obtain a result indicating whether that string is generated by the black box. All the information gathered across all the turns is used to reverse engineer the black box. Throughout the process, you can decide whether the gathered information is sufficient to correctly identify the workings of the black box, in which case you can stop. Otherwise you need to continue the interaction.

  Concretely, you can perform one of the following actions at each turn: 1) test, or 2) stop. Below is the format for each action.

  Test:
  ```test
  Str
  ```

  Stop:
  ```stop
  stop
  ```
  Note that you should only perform one of the actions above with one input example in your response. 

  Below is your past observations of the black box:
  {observations}
  Provide a *thorough reasoning* before performing the action. Leverage the past observations to design your next query

  Response:

